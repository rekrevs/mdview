# T-0011: Analyze feasibility of building custom markdown+math renderer from scratch

**Status**: DONE
**Phase**: —

## Context

Given the challenges with third-party libraries (MarkdownUI maintenance-only, MarkdownView blocked by #Preview macro), we need to assess whether building our own renderer is feasible.

Key questions:
1. What do the existing libraries actually do? How complex is the code?
2. What are the core components we'd need to build?
3. How hard is markdown parsing vs rendering?
4. How hard is math/LaTeX rendering specifically?
5. What's the effort vs reward tradeoff?

## Acceptance Criteria

- [ ] Analyze MarkdownUI source code structure and complexity
- [ ] Analyze swift-markdown (Apple's parser) - can we use just this?
- [ ] Analyze SwiftMath source code for math rendering complexity
- [ ] Analyze LaTeXSwiftUI/MathJax approach for comparison
- [ ] Document effort estimates for each component
- [ ] Provide GO/NO-GO recommendation

## Key Components to Analyze

### 1. Markdown Parsing
- swift-markdown (Apple) - already stable, could we use directly?
- cmark-gfm - C library, what does wrapping require?

### 2. Markdown Rendering (AST → SwiftUI)
- How does MarkdownUI convert parsed AST to views?
- What styling/theming is involved?
- How complex is table rendering? Code blocks?

### 3. Math Parsing
- How do you parse `$...$` and `$$...$$` within markdown?
- Integration with markdown AST

### 4. Math Rendering
- SwiftMath: native CoreGraphics - how complex?
- MathJax: WebView-based - simpler integration but overhead
- What LaTeX subset is actually needed?

## Verification Plan

N/A - This is a research/analysis task.

## Analysis Results

### 1. swift-markdown (Apple's Parser) - REUSABLE

| Metric | Value |
|--------|-------|
| Lines of code | ~15,000-20,000 |
| Source files | ~70 Swift files |
| Node types | 34 (with visitor pattern) |
| Maintenance | Active (Apple/Swift team) |
| License | Apache 2.0 |

**Key insight**: This is a pure parser with no rendering. It provides:
- CommonMark + GFM parsing
- Full AST with visitor pattern (`MarkupVisitor` protocol)
- No dependencies issues (no `#Preview` macros)

**Verdict**: ✅ We can use this directly. No need to reimplement parsing.

---

### 2. MarkdownUI Renderer Structure

| Metric | Value |
|--------|-------|
| Source files | ~150 files |
| Architecture | Parser → Theme → Views |
| Pattern | Switch-based view composition |

**How it works:**
```swift
switch blockNode {
case .blockquote(let children): BlockquoteView(children: children)
case .heading(let level, let children): HeadingView(level: level, children: children)
// ... 20+ more cases
}
```

**Key components:**
- Block views: ~15 (heading, list, table, code, blockquote, etc.)
- Inline views: ~10 (text, emphasis, strong, link, image, code)
- Theme system: Style definitions for each element
- Environment propagation: SwiftUI environment for config

**Effort to rebuild**:
- Minimal version: ~500-1000 lines (basic rendering)
- Full-featured with theming: ~2000-3000 lines

**Verdict**: ✅ FEASIBLE to build ourselves. Pattern is straightforward.

---

### 3. SwiftMath (Math Rendering) - COMPLEX

| Component | Size | Complexity |
|-----------|------|------------|
| LaTeX parser (`MTMathListBuilder`) | ~55KB | Moderate |
| Typesetter (`MTTypesetter`) | ~127KB | **High** |
| Atom factory (`MTMathAtomFactory`) | ~45KB | Moderate |
| Font handling | ~30KB | Moderate |
| **Total** | ~300KB+ | **Very High** |

**What the typesetter does:**
- Implements TeX math layout rules
- Handles fractions, radicals, scripts, large operators
- Manages inter-element spacing per TeX specification
- Line breaking with penalty scoring
- Delimiter stretching (parentheses that grow)
- Accent positioning

**LaTeX features supported:**
- `\frac`, `\sqrt`, `\sum`, `\int`, matrices
- Sub/superscripts with complex gap rules
- Greek letters, operators, relations
- Font styles (bold, italic, calligraphic)
- Environments (`\begin{matrix}`, etc.)

**Verdict**: ❌ NOT FEASIBLE to rebuild. This is specialized typesetting code that took years to develop (iosMath → SwiftMath lineage).

---

### 4. Alternative: MathJax/LaTeXSwiftUI

| Aspect | MathJax | SwiftMath |
|--------|---------|-----------|
| Engine | JavaScript (WebView) | Native Swift |
| LaTeX coverage | Complete | ~80% |
| Performance | Slower | Faster |
| Complexity to use | Easy | Easy |
| Complexity to build | N/A (use as-is) | Very High |

---

## Effort Estimates

| Component | From Scratch | Using Existing |
|-----------|--------------|----------------|
| Markdown parsing | ❌ ~3 months | ✅ 0 (swift-markdown) |
| Markdown → SwiftUI | ⚠️ 1-2 weeks | ✅ 0 (MarkdownUI) |
| Math parsing | ❌ 1-2 months | ✅ 0 (SwiftMath) |
| Math rendering | ❌ 3-6 months | ✅ 0 (SwiftMath) |
| **Total from scratch** | **6-12 months** | **0** |

---

## Recommendation

### Custom Markdown Renderer: ✅ FEASIBLE

We CAN build our own markdown-to-SwiftUI renderer because:
1. Use swift-markdown for parsing (0 effort)
2. Implement `MarkupVisitor` to produce SwiftUI views
3. ~1000-2000 lines for a working renderer
4. Pattern is well-understood (switch + view per node type)

**Benefits:**
- No `#Preview` macro issues (swift-markdown doesn't use them)
- Full control over rendering
- Can integrate math at AST level

### Custom Math Renderer: ❌ NOT FEASIBLE

We should NOT try to build math rendering because:
1. Typesetting is a specialized domain (TeX algorithms)
2. ~300KB of complex layout code in SwiftMath
3. Years of development by multiple contributors
4. Edge cases in fonts, spacing, and layout

**Better approach**: Use SwiftMath directly (no `#Preview` issues in SwiftMath itself)

---

## Proposed Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                        mdview                                │
├─────────────────────────────────────────────────────────────┤
│  ContentView                                                 │
│    ├── CustomMarkdownRenderer (OUR CODE)                    │
│    │     ├── swift-markdown (Apple)      ← parsing          │
│    │     └── SwiftUI views               ← rendering        │
│    │           └── MathView              ← for $...$ nodes  │
│    │                 └── SwiftMath       ← math rendering   │
│    └── [existing features: zoom, scroll, file watch]        │
└─────────────────────────────────────────────────────────────┘

Dependencies:
- swift-markdown (Apache 2.0, no #Preview) ← PARSER
- SwiftMath (MIT, no #Preview)             ← MATH ONLY
```

**This eliminates:**
- MarkdownUI (maintenance mode, uses cmark internally anyway)
- MarkdownView (blocked by #Preview)
- LaTeXSwiftUI/MathJax (WebView overhead)

---

## GO/NO-GO Decision

### GO for: Custom Markdown Renderer + SwiftMath

**Rationale:**
1. swift-markdown + SwiftMath both work on command-line SPM
2. We control the AST → can integrate math at parse level
3. ~1-2 weeks effort for basic renderer
4. Eliminates third-party rendering libraries
5. Future-proof (we control the code)

### NO-GO for: Building Math Rendering from Scratch

**Rationale:**
1. Would take 3-6 months minimum
2. Requires deep TeX/math typesetting expertise
3. SwiftMath already does this well
4. No benefit vs just using SwiftMath

---

## Next Steps (if proceeding)

1. Add swift-markdown + SwiftMath dependencies (both clean)
2. Implement `MarkupVisitor` that produces SwiftUI views
3. Add math-aware pre-processing to find `$...$` in Text nodes
4. Replace `$...$` with SwiftMath views in output
5. Test with test-math.md

## Obstacles

None - this approach avoids all the `#Preview` issues.

## Evidence

- swift-markdown source analysis: 34 node types, visitor pattern
- MarkdownUI source analysis: switch-based view composition
- SwiftMath source analysis: 300KB+ of specialized typesetting code
- Confirmed swift-markdown and SwiftMath don't use `#Preview`

## Outcome

**GO**: Build custom renderer using swift-markdown + SwiftMath

This approach:
- Eliminates problematic dependencies (MarkdownUI, MarkdownView)
- Uses stable, well-maintained libraries (Apple + SwiftMath)
- Gives us full control over rendering
- Properly integrates math at AST level (not regex)
